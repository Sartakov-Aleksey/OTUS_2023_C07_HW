#include <stdio.h>
#include <stdlib.h> 
#include <string.h>
#include <wctype.h> 
#include <wchar.h> 
#include <time.h> 
#include <ctype.h>
#include <iso646.h>
#include <stdbool.h>
#include <uchar.h>  //  /usr/include/uchar.h
#include <locale.h>
#include <math.h>
#include <tgmath.h>
#include <threads.h> 
#include <unistd.h> // для sleep() read()
#include <errno.h> // return EXIT_SUCCESS; 

#include <stdint.h>
#include <malloc.h>

#define РАЗМЕР_W_БУФЕРА 1000000
#define БУФЕР_32 32
#define БУФЕР_256 256 


// в данном примере эти переменные указаны в текущем файле. 
// В большом проекте - эти переменные перенёс бы в отдельный заголовочник ГЛОБАЛЬНЫХ переменных.
wchar_t arr_wchar_1[64]=L"АБВГДЕЖЗИЙКЛМНОПРСТУФХЦЧШЩЪЫЬЭЮЯабвгдежзийклмнопрстуфхцчшщъыьэюя";
wchar_t arr_wchar_2[64]=L"АБВГДЕЖЗИЙКЛМНОПРСТУФХЦЧШЩЪЫЬЭЮЯабвгдежзийклмнопрстуфхцчшщъыьэюя";
wchar_t arr_wchar_3[64]=L"юабцдефгхийклмнопярстужвьызшэщчъЮАБЦДЕФГХИЙКЛМНОПЯРСТУЖВЬЫЗШЭЩЧЪ";


// функцию по переводу одной буквы из указанной кодировки в широкий символ
wchar_t f_разбор_кодировки(int id_кодировки, unsigned char один_символ);


int main(int argc, char **argv)
{
    if (argc != 4) // ошибка, нехватка ключей для запуска программы.
    {
        printf("\nПрограмма НЕ имеет нужного количества параметров на входе. "
                "Сейчас указан(о) %i параметр(ов).\n", argc);
        puts("Первый параметр: 'имя входного файла', который нужно расшифровать/перекодировать. "
            "Файл должен находится в папке запуска программы или с полным адресом до этого файла на вашем ПК.");
        puts("Второй ='Название кодировки'. Варианты: cp1251 (или 1), iso-8859-5 (или 2), koi8 (или 3). Только латинские буквы или цифры.");
        puts("Третий='Выходной файл' (перекодированный). Выходной файл нужно указывать с полныи адресом для его сохранения (полный путь для сохранения файла).");
        return 1; 
    }
    


    unsigned char буква_анализ;
    wchar_t w_буква;
    wchar_t w_строка_подмена[2];
    w_строка_подмена[1]='\0';
    wchar_t буфер_для_вывода[РАЗМЕР_W_БУФЕРА]=L""; 
    int id_кодировки;
    
    FILE *файл_чтение;
    FILE *файл_запись;
    long int счётчик =0;
    
    char имя_файла[БУФЕР_256];
    strncpy(имя_файла, argv[1], БУФЕР_256-1); 
    
    char имя_кодировки[БУФЕР_32];
    strncpy(имя_кодировки, argv[2], БУФЕР_32-1);     
        
    char выходной_файл[БУФЕР_256];
    strncpy(выходной_файл, argv[3], БУФЕР_256-1); 


    setlocale(LC_ALL, "ru_RU. UTF-8"); //(LC_ALL, "")); // устанавливаем русскую кодировку (на всякий случай)
    

    // открываем входной файл
    if ((файл_чтение = fopen(имя_файла, "r")) == NULL)
    {
        locale_t locale = newlocale(LC_ALL_MASK, "ru_RU.UTF-8", (locale_t) 0);
        printf("Программе не удаётся открыть файл %s. \n", имя_файла);
        perror("fopen() ошибка");   //printf("%i) %s\n", kk, strerror_l(kk, locale));
        puts("Программе завершает работу. \n");
        freelocale(locale);   
        return 1;
    }

    // создаём файл для записи
    if ((файл_запись = fopen(выходной_файл, "w+")) == NULL)
    {
        locale_t locale = newlocale(LC_ALL_MASK, "ru_RU.UTF-8", (locale_t) 0);
        printf("Программе не удаётся СОЗДАТЬ файл %s по указанному вами адресу. \n", имя_файла);
        perror("fopen() ошибка");   //printf("%i) %s\n", kk, strerror_l(kk, locale));
        puts("\nДля записи итогового файла нужно указать полный путь к папке и имя файла (без пробелов или в двойных кавычках).\n");
        puts("Проверьте права на работы с файлом.\nПрограмме завершает работу.\n");
        freelocale(locale);   
        fclose(файл_чтение);
        return 1;
    }
    

    // определяем тип кодировки для разбора файлов
    if (0==strcmp(имя_кодировки, "cp1251") or 0==strcmp(имя_кодировки, "1"))
    {
        id_кодировки=1;
    }
    else if (0==strcmp(имя_кодировки, "iso-8859-5") or 0==strcmp(имя_кодировки, "2"))
    {
        id_кодировки=2;
    }        
    else if (0==strcmp(имя_кодировки, "koi8") or 0==strcmp(имя_кодировки, "3"))
    {
        id_кодировки=3;
    }
    
    
    while (( буква_анализ = fgetc(файл_чтение)) != EOF)
    {
        // в примере = cp1251.txt конец файла = EOF не определяется. Пришлось включить эту доп.функцию
        if (feof (файл_чтение)) 
        {
            printf("\nДостигли конца файла.\n\n");
            break;
        }
        
        w_буква = f_разбор_кодировки(id_кодировки, буква_анализ);
        w_строка_подмена[0]=w_буква;
        wcscat(буфер_для_вывода, w_строка_подмена); 
        счётчик ++;
        
        // определяем размер занятого буфера широкими символами
        // если он близок к заданной величине = РАЗМЕР_W_БУФЕРА, то сохраняем буфер в файл и обнуляем буфер      
        if (счётчик > РАЗМЕР_W_БУФЕРА-10)
        {
            fputws(буфер_для_вывода, файл_запись);
            wcscpy(буфер_для_вывода, L"");
            счётчик = 0;
        }
    }
    
    fputws(буфер_для_вывода, файл_запись);
    
    fclose(файл_чтение); 
    fclose(файл_запись); 

	return 0;
}







wchar_t f_разбор_кодировки(int id_кодировки, unsigned char один_символ)
{
    wchar_t w_буква;
    
    if (1==id_кодировки) // "cp1251" =  Windows-1251
    {
        if (один_символ<192)
        {
            switch (один_символ)
            {
                case 168:
                w_буква = L'Ё';
                break;
                case 184:
                w_буква = L'ё';
                break; 
 
                default:
                w_буква = один_символ;
            }
        }
        else
        {
            unsigned int номер;
            номер = (unsigned int) один_символ - 192;
            w_буква = arr_wchar_1[номер];
        }
    }
    else if (2==id_кодировки) // "iso-8859-5"
    {
        if (один_символ<192)
        {
            switch (один_символ)
            {
                case 161:
                w_буква = L'Ё';
                break;
                
                default:
                w_буква = один_символ;
            }
        }
        else if (один_символ<240)
        {
            unsigned int номер;
            номер = (unsigned int) один_символ - 176;
            w_буква = arr_wchar_2[номер];
        }
        else 
        {
            if (241 == один_символ)
            {
                w_буква = L'ё';
            }
            else
            {
                w_буква = один_символ;
            }
        }
    }
    else if (3==id_кодировки) // "koi8"
    {
        if (один_символ<192)
        {
            if (163==один_символ)
            {
                w_буква = L'ё';
            }
            else if (179==один_символ)
            {
                w_буква = L'Ё';
            }
            else
            {
                w_буква =один_символ;
            }
        }
        else
        {
            unsigned int номер;
            номер = (unsigned int) один_символ - 192;
            w_буква = arr_wchar_3[номер];
        }
    }
    
    return w_буква;
}