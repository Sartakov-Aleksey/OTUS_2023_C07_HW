#include <stdio.h>
#include <stdlib.h> 
#include <string.h>
#include <wctype.h> 
#include <wchar.h> 
#include <time.h> 
#include <ctype.h>
#include <iso646.h>
#include <stdbool.h>
#include <uchar.h>  //  /usr/include/uchar.h
#include <locale.h>
#include <math.h>
#include <tgmath.h>
#include <threads.h> 
#include <unistd.h> // для sleep() read()
#include <errno.h> // return EXIT_SUCCESS; 


#ifdef __linux__
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <unistd.h>
#endif


#define ДЛИНА_СЛОВА 6
#define ДЛИНА_ВХОДНОГО_ФАЙЛА 256 
#define РАЗМЕР_W_БУФЕРА 100
#define ОСНОВАНИЕ_КЛЮЧА 13
#define СТЕПЕНЬ_КЛЮЧА 17
#define ШАГ_ИНТЕРВАЛА_ПОВТОРОВ 1 



struct структ_хэш_записи {
    wchar_t текст[54];
    bool метка_об_удалении; // true если эту запись удалили
    int повторов;
};



int main(int argc, char **argv)
{
    if (argc != 2) // ошибка, нехватка ключей для запуска программы.
    {
        printf("\nПрограмма НЕ имеет нужного количества параметров на входе. "
                "Сейчас указан(о) %i параметр(ов).\n", argc);
        puts("Первый параметр: 'имя входного файла', который нужно проанализировать. "
            "Файл должен находится в папке запуска программы или с полным адресом до этого файла на вашем ПК.");
        return 1; 
    }
    
    
    puts("\nПрограмма написана для работы с русскими словами!\n" 
    "При работе с только с латинскими буквами (первыми 127 символами ASCII) "
    "первоначальный размер массива ХЭШ таблицы будет определяться некорректно.\n"); 
    puts("Все слова переводятся и сравниваются в НИЖНЕМ регистре (как маленькие буквы).");
    puts("Разделение на слова проходит по пробелу, табуляции или символу новой строки (перевод строки).");
    puts("Если слово имеет ручной перенос (пере-малывает), \n" 
    "то программа будет анализировать именно слова с 'дефисом внутри' \n"
    "или как два разных слова 'пере-' и 'малывает' если после 'пере-' стоит символ новой строки.\n");



    wchar_t буфер_для_вывода[РАЗМЕР_W_БУФЕРА]=L""; // первоначальная строка из файла (с кучей ненужных символов
    wchar_t temp_w_буфер[РАЗМЕР_W_БУФЕРА]=L"";  // очищенная строка из файла, в которой удалены (),.  и переведённая в нижний регистр букв
    wchar_t w_строка_подмена[2];
    w_строка_подмена[1]='\0';
    
    bool цикл=true;

    long int размер_файла_b =0;
    int размер_хэш_таблицы=0; // первоначальное кол-во индексов/записей в хэш таблице
    int id =0;
    unsigned long long int хэш_сумма=0;
    struct stat _fileStatbuff;
    FILE *файл_чтение;
    
    
    char имя_файла[ДЛИНА_ВХОДНОГО_ФАЙЛА];
    strncpy(имя_файла, argv[1], ДЛИНА_ВХОДНОГО_ФАЙЛА-1); 
    

    // Средняя длина русского слова 6 символов. Один русский символ занимает 2 байта. 
    // Длину файла в байтах делим на 6*2 - это количество слов. 
    // Рекомендуемая разряженность массива составляет 70%, 
    // Поэтому массив для для работы с ХЭШ таблицами грубо увеличиаю на 30%. Итого получаем размер хэш таблицы как строк =1,30 * размер_файла/12.
    
   
    setlocale(LC_ALL, "ru_RU. UTF-8"); //(LC_ALL, "")); // устанавливаем русскую кодировку (на всякий случай)
    

    // открываем входной файл
    if ((файл_чтение = fopen(имя_файла, "r")) == NULL)
    {
        locale_t locale = newlocale(LC_ALL_MASK, "ru_RU.UTF-8", (locale_t) 0);
        printf("Программе не удаётся открыть файл %s. \n", имя_файла);
        perror("fopen() ошибка");   //printf("%i) %s\n", kk, strerror_l(kk, locale));
        puts("Программе завершает работу. \n");
        freelocale(locale);   
        return 1;
    }

    // узнаём размер анализируемого файла в байтах
    int fd = open(имя_файла, O_RDONLY);
    if(fd == -1)
    {
        размер_файла_b = -1;
    }
    else
    {
        if ((fstat(fd, &_fileStatbuff) != 0) || (!S_ISREG(_fileStatbuff.st_mode))) {
            размер_файла_b = -1;
        }
        else{
            размер_файла_b = _fileStatbuff.st_size;
        }
        close(fd);
    }

    if (размер_файла_b<1)
    {
        puts("Файл не имеет данных или проблема с их чтением (сбой)." );
        return -1;
    }
    
    
    размер_хэш_таблицы = (int) (1.30 * размер_файла_b/12);
    размер_хэш_таблицы = (размер_хэш_таблицы<15) ? размер_хэш_таблицы*2 : размер_хэш_таблицы;
    printf("Размер файла: %li bite. Длина ХЭШ массива составит %i записей.\n", размер_файла_b, размер_хэш_таблицы);
    
    // можно указать, что код работать не будет, т.к размер выделяемой памяти очень большой (к примеру более 1 Гб)
    
    
    // выделяем память под таблицу со значениями
    struct структ_хэш_записи *гл_структура_хэш_записи = calloc(размер_хэш_таблицы, sizeof(struct структ_хэш_записи)); 
   
    
    // ключи/коэффициенты/переменные для вычислений ХЭШ функций
    // h(S)  =  S[0]  +  S[1] * P  +  S[2] * P^2  +  S[3] * P^3  +  ...  +  S[N] * P^N
    // встречаются слова с 17 буквами "узкокорпоративных"
    const int p = ОСНОВАНИЕ_КЛЮЧА; // основание ключа, т.к слова с 17 буквами не редкость и с основанием по даже 17 - мы очень сильно превышаем long long int (2 в 64)
    unsigned long long int arr_степени_ключа[СТЕПЕНЬ_КЛЮЧА+1]; // 13 в 17 степени
    unsigned long long int ключ=1;
    for (int i=0; i<=СТЕПЕНЬ_КЛЮЧА; i++)
    {
        arr_степени_ключа[i]=ключ;
        ключ *=p;
        //printf("%llu\n", arr_степени_ключа[i]);
    }
    

    // считаем слова
    while (цикл == true) 
    {
        if (feof(файл_чтение)) 
        {
            printf("\nДостигли конца файла.\n\n");
            цикл = false;
            break;
        }
        fwscanf(файл_чтение, L"%ls", буфер_для_вывода); 
            //printf("%ls\n", буфер_для_вывода);
          
          
        //вычисляем хэш функцию 
        wcscpy(temp_w_буфер, L"");
        for (int i=0; i<wcslen(буфер_для_вывода); i++)
        {
            //ПРИМЕЧАНИЕ: h(S)  =  S[0]  +  S[1] * P  +  S[2] * P^2  +  S[3] * P^3  +  ...  +  S[N] * P^N
             if  (','==буфер_для_вывода[i] 
                or '.'==буфер_для_вывода[i] 
                or '('==буфер_для_вывода[i] 
                or ')'==буфер_для_вывода[i])
            {
                continue;
            }
            w_строка_подмена[0]= towlower(буфер_для_вывода[i]);
            хэш_сумма = (хэш_сумма + w_строка_подмена[0] - L'a' + 1) * arr_степени_ключа[i];
              
            wcscat(temp_w_буфер, w_строка_подмена);
            //printf("%lc\t%llu\n", буфер_для_вывода[i], хэш_сумма);
            w_строка_подмена[0]='\0';
        }
        
      
      
        // находим индекс в хэш таблице
        id = хэш_сумма % размер_хэш_таблицы;
        printf("in: %ls \t out: %ls \t id: %i\n", буфер_для_вывода, temp_w_буфер, id);
        
        if (wcslen(temp_w_буфер)>0) // последняя запись (перевод строки несколько раз в конце) выдают, ложные срабатывания
        {
            if (0==гл_структура_хэш_записи[id].повторов)
            {
                
                wcscpy(гл_структура_хэш_записи[id].текст, temp_w_буфер);
                гл_структура_хэш_записи[id].повторов = 1;
            }
            else
            {
                // !!!!!!!!!!!
                // В задаче нет проверки функции на коллизии, поэтому проверок нет и просто увеличивается счётчик на +1
                    // проверку делал бы через    0==wcscmp(гл_структура_хэш_записи[id].текст, temp_w_буфер)
                гл_структура_хэш_записи[id].повторов += 1;
            }
        }
    
      хэш_сумма=0;
      wcscpy(буфер_для_вывода, L""); // если в конце несколько переводов строк, то последнее слово считается неколько раз (дублируется)
      wcscpy(temp_w_буфер, L"");
    }
    
    
    
    
    
    // выводим НЕ ОТСОРТИРОВАННЫЙ список слов с их количеством.
    for (int i=0; i<размер_хэш_таблицы; i++)
    {
        if (0==гл_структура_хэш_записи[i].повторов)
        {
            continue;
        }
        printf("%3i) \t%ls \t\t %2i раз\n", i, гл_структура_хэш_записи[i].текст, гл_структура_хэш_записи[i].повторов);
    }
    


    
    fclose(файл_чтение); 
    free(гл_структура_хэш_записи);
	return 0;
}




